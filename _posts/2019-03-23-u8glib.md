---
layout: post
title:  Arduino库之U8g2lib
date:   2019-03-23 22:22:00 +0800
categories: document
tag: Raspberry Pi/Arduino
---

* content
{:toc}
>某些图片、表格在手机竖屏状态下会显示不全，横屏显示即可。
>
>大部分内容摘自官网，若有错误或想与我交流，请微信联系310378072，或邮件联系todd310378072@outlook.com



# 简介                                     {#introduction}

![U8g2](https://raw.githubusercontent.com/wiki/olikraus/u8g2/img/uc1701_dogs102_uno_board_320.jpg "U8g2")

&emsp;&emsp;U8glib是用于单色显示屏的图形库，它可以用于51、Arduino目前作者[olikraus](https://github.com/olikraus)已经更新到version2了，也就是U8g2lib（下面简称U8g2）。U8g2这个库实际上包含两个库(api)：U8g2和U8x8，它们有如下特点：

* U8g2
  * 可处理所有图形
  * 支持[很多字体](https://github.com/olikraus/u8g2/wiki/fntlistall)（点击查看）。（几乎）对字体大小没限制
  * 微控制器需要一定的存储空间来传递显示
* U8x8
  * 只能输出文字
  * 只能输出固定像素的字体
  * 直接输出到显示屏，微控制器无需缓冲区

&emsp;&emsp;这两个库还包含一个特殊的类（也能看作一个子库）：U8log，它能模拟一个输出终端，功能如下：

* U8log
  * Output of boot/startup information 输出初始化信息
  * Error logging 载入错误
  * Debugging logging 载入debug
  * Output of sensor values 输出传感器值（我看上的是这一点）

&emsp;&emsp;下面我们结合实际操作来学习。

---





# 安装U8g2                                       {#install}

&emsp;&emsp;进入Arduino IDE，点击上方“工具”-“管理库”，搜索U8g2，选择U8g2 by oliver那个，点击安装即可。 

![安装U8g2](https://raw.githubusercontent.com/wiki/olikraus/u8g2/img/arduino_ide_search_u8g2.png "安装U8g2")

---





# Hello World!

&emsp;&emsp;按照惯例，我们先输出一个Hello World!。点击上方“文件”-“示例”-“U8g2”-“full_buffer”-“HelloWorld”，先不要急着上传到Arduino，要先根据你的屏幕控制器、像素，删掉其中一个注释的`//`。我的型号是淘宝上常见的0.96 OLED（下图），所以我用的是这句：`U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);`。

![我的OLED](https://startingelectronics.org/tutorials/arduino/modules/OLED-128x64-I2C-display/geekcreit-128x64-oled-display-demo.jpg "我的OLED")

&emsp;&emsp;上传，接好线，上电，就可以看到屏幕上出现”Hello World!“（位置可能和上图不一样）

---





# 配置         {#setup}

&emsp;&emsp;虽然上面的”HelloWorld“看起来很长，但实际上只有以下几句：

```c++
#include <U8g2lib.h>
#include <Wire.h>
U8G2_SSD1306_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

void setup(void) {
  u8g2.begin();
}

void loop(void) {
  u8g2.clearBuffer();         // clear the internal memory
  u8g2.setFont(u8g2_font_ncenB08_tr); // choose a suitable font
  u8g2.drawStr(0,10,"Hello World!");  // write something to the internal memory
  u8g2.sendBuffer();          // transfer internal memory to the display
  delay(1000);  
}
```

&emsp;&emsp;开头第一句是引用U8g2，我们着重看第二句，它就是配置”Setup“，具体分成以下几部分：

| Description      | Example                    |
| ---------------- | -------------------------- |
| 前缀             | `U8G2`                     |
| 控制器（驱动器） | `SSD1306`                  |
| 显示屏           | `128x64_NONAME`            |
| 缓冲区大小       | `1`、`2`、或`F`(full)      |
| 通信协议         | `HW_I2C`                   |
| 参数             | `(U8G2_R0, U8x8_PIN_NONE)` |



## 控制器/显示屏名字

&emsp;&emsp;这个没什么好讲的，一般淘宝上都会标出来，实在不知道就问商家，再不行就挨个试一下符合像素的那几句。



## 缓冲区大小      {#BufferSize}

&emsp;&emsp;`1`表示RAM中只会储存一页画面的缓冲。你需要用一个`firstPage()/nextPage()`循环来显示。

&emsp;&emsp;`2`和1类似，但会储存两页。官网还说`2`是`1`的两倍快，但我实在不知道”快“指的是什么。

&emsp;&emsp;`F`表示“full frame buffer”，储存所有页面，用`clearBuffer()`来清除缓冲，用`sendBuffer()`来把缓冲发送到显示屏。



## 通信协议

&emsp;&emsp;支持常见的SPI、I2C、6800和8080，支持硬件`HW`和软件`SW`，具体有下面几种：

| 通信协议        | 描述                                              |
| --------------- | ------------------------------------------------- |
| `4W_SW_SPI`     | 4线（clock, data, cs and dc）软件模拟SPI          |
| `4W_HW_SPI`     | 4线（clock, data, cs and dc）硬件SPI（基于SPI库） |
| `2ND_4W_HW_SPI` | 如果板子支持，第二个 4线硬件SPI                   |
| `3W_SW_SPI`     | 3线(clock, data and cs)软件模拟SPI                |
| `SW_I2C`        | 软件模拟 I2C/TWI                                  |
| `HW_I2C`        | 硬件 I2C （基于Wire库）                           |
| `2ND_HW_I2C`    | 如果板子支持，第二个 硬件 I2C （基于Wire库）      |
| 6800            | 8-bit并行接口，6800协议                           |
| 8080            | 8-bit并行接口，8080协议                           |

&emsp;&emsp;某些处理器支持硬件I2C重映射，可以重设管脚：`..._HW_I2C([reset [, clock, data])`，如果没有，reset就设为`U8X8_PIN_NONE`。具体看[官网](<https://github.com/olikraus/u8g2/wiki/u8g2setupcpp#communication>)。

&emsp;&emsp;软件模拟 I2C 需要设置SCL，SDA对应管脚：`..._SW_I2C(clock, data [, reset])`。



## 旋转

&emsp;&emsp;这是配置语句的第一个参数，有如下几种选择：

| 旋转/镜像     | 描述             |
| ------------- | ---------------- |
| `U8G2_R0`     | 不旋转           |
| `U8G2_R1`     | 顺时针旋转90度   |
| `U8G2_R2`     | 顺时针旋转180度  |
| `U8G2_R3`     | 顺时针旋转270度  |
| `U8G2_MIRROR` | 不旋转，镜像翻转 |



## 接线

&emsp;&emsp;官网上的表格：

| Pin Argument | Description | Datasheet Names |
|--------------|-------------|-----------------|
| clock | SPI or I2C clock line | SCL, SCLK, ... |
| data | SPI or I2C data line | SDA, MOSI, SDIN, ... |
| d0 ... d7 | Data lines of the parallel interface | D0 ... D7 |
| cs | Chip select line | CS |
| dc | Data/command selection line (register select) | D/C, A0, RS, ... |
| enable | "Write" for the 8080 interface, "enable" for the 6800 interface | 8080: WR, 6800: E |
| reset | Reset line | |

&emsp;&emsp;如果你不需要用某个引脚但又需要一个参数，可以用`U8X8_PIN_NONE`



## 16 Bit模式

&emsp;&emsp;U8g2默认是8 Bit Mode，如果你的设备支持 256或以上的像素宽，你可以在`u8g2.h`文件中取消注释`//#define U8G2_16BIT`。



## SSD1306 128X64_NONAME

&emsp;&emsp;由于这个模块比较常用，所以我把它的详细介绍搬了过来。其他模块请去[官网](<https://github.com/olikraus/u8g2/wiki/u8g2setupcpp#constructor-reference>)。（显示不全的话请横屏查看）

| Controller "ssd1306", Display "128x64_noname" | Descirption |
|---|---|
| U8G2_SSD1306_128X64_NONAME_1_SW_I2C(rotation, clock,  data [,  reset]) | page buffer, size = 128 bytes |
| U8G2_SSD1306_128X64_NONAME_2_SW_I2C(rotation, clock,  data [,  reset]) | page buffer, size = 256 bytes |
| U8G2_SSD1306_128X64_NONAME_F_SW_I2C(rotation, clock,  data [,  reset]) | full framebuffer, size = 1024 bytes |
| U8G2_SSD1306_128X64_NONAME_1_HW_I2C(rotation, [reset [, clock, data]]) | page buffer, size = 128 bytes |
| U8G2_SSD1306_128X64_NONAME_2_HW_I2C(rotation, [reset [, clock, data]]) | page buffer, size = 256 bytes |
| U8G2_SSD1306_128X64_NONAME_F_HW_I2C(rotation, [reset [, clock, data]]) | full framebuffer, size = 1024 bytes |
| U8G2_SSD1306_128X64_NONAME_1_2ND_HW_I2C(rotation, [reset]) | page buffer, size = 128 bytes |
| U8G2_SSD1306_128X64_NONAME_2_2ND_HW_I2C(rotation, [reset]) | page buffer, size = 256 bytes |
| U8G2_SSD1306_128X64_NONAME_F_2ND_HW_I2C(rotation, [reset]) | full framebuffer, size = 1024 bytes |

---





# 控制函数

&emsp;&emsp;下面一些控制函数，能对全局进行操作。

## begin                                      {#begin}

* 函数原型：

  ```c++
  bool U8G2::begin(void)
  bool U8G2::begin(uint8_t menu_select_pin, uint8_t menu_next_pin, uint8_t menu_prev_pin, uint8_t menu_up_pin = U8X8_PIN_NONE, uint8_t menu_down_pin = U8X8_PIN_NONE, uint8_t menu_home_pin = U8X8_PIN_NONE)
  ```


* 描述：用上面的配置设置显示屏，并且会清空显示屏，退出显示屏的省电模式。还可以设置按键：将按键的对应引脚传递到对应参数（按键要求低有效），用[getMenuEvent](#getMenuEvent)来检查按键事件，从而构建用户交互界面。

* 这个函数会调用：

  1. [initDisplay](#initDisplay)
  2. [clearDisplay](#clearDisplay)
  3. [setPowerSave](#setPowerSave)

* 返回值：永远是1/true

* 相关：[initDisplay](#initDisplay) [setPowerSave](#setPowerSave) [clearDisplay](#clearDisplay) [U8X8::begin](https://github.com/olikraus/u8g2/wiki/u8x8reference#begin)

* 例子：这个函数一般放在`void setup(void)`里面：

  ```c++
  void setup(void) {
    u8g2.begin();
  }
  ```



## initDisplay                     {#initDisplay}

* 函数原型：

  ```c++
  void U8G2::initDisplay(void) 
  ```

* 描述：重新设置显示屏。显示前一定要先调用这个函数。它会让屏幕处在省电模式。要让屏幕显示，先取消省电模式（[setPowerSave](setPowerSave)）
* 相关：[setPowerSave](#setPowerSave), [begin](#begin)



## setPowerSave                     {#setPowerSave}

* 原型：

  ```c++
  void U8G2::setPowerSave(uint8_t is_enable)
  ```

* 描述：开启（is_enable=1）或关闭（is_enable=0）显示屏的省电模式。当省电模式开启时，屏幕上的内容不可见，屏幕RAM的内容未更改。这个函数在[begin](#begin)被调用。

* 参数：

  * is_enable：开启（1）或关闭（0）显示屏的省电模式。

* 相关：[begin](#begin)

## clear                                             {#clear}

* 函数原型：

  ```c++
  void U8G2::clear(void)
  ```

* 描述：清空屏幕（display）和缓冲区（buffer）的所有像素（说实话我分不清这俩）。将[print](#print)的指针（cursor）归位到左上角。
* 这个函数会调用：
  1. [home](#home)
  2. [clearDisplay](#clearDisplay)
  3. [clearBuffer](#clearBuffer)
* 相关：[home](#home) [clearDisplay](#clearDisplay) [clearBuffer](#clearBuffer)



## clearDisplay                      {#clearDisplay}

* 函数原型：

  ```c++
  void U8G2::clearDisplay(void)  
  ```

* 描述：清空内部和显示屏的缓冲区的像素。这个函数在[begin](#begin)函数内被调用，因此除了初始化时之外，无需再调用这个函数。其他函数，如 [sendBuffer](#sendBuffer) 和 [nextPage](#nextPage)) ，也能覆盖/清空显示。

* 注：

  * 这个命令可以对`_F_`、`_1_`、`_2_`三种缓冲区大小都有效
  * 不要在单页的循环内使用这个命令（在[firstPage](#firstPage)和[nextPage](nextPage)）

* 相关：[begin](#begin)




## clearBuffer                         {#clearBuffer}

* 函数原型：

  ```c++
  void U8G2::clearBuffer(void)
  ```

* 描述：清空内部缓冲区的所有像素。清楚后，用 [sendBuffer](#sendBuffer) 来将新的页面传递给显示屏。这个函数只对`_F_`（储存所有页面）的情况有效（见上面的[缓冲器大小](#BufferSize)）。它还会发送一个刷新信号（[refreshDisplay](#refreshDisplay)）给墨水屏。

* 相关：[sendBuffer](#sendBuffer)

* 示例：

  ```c++
  void loop(void) {
    u8g2.clearBuffer();
    // ... write something to the buffer 
    u8g2.sendBuffer();
    delay(1000);
  ```



## sendBuffer             {#sendBuffer}

* 函数原型：

  ```c++
  void U8G2::sendBuffer(void) 
  ```

* 描述：将内存缓冲区中的内容发送给显示。用 [clearBuffer](clearBuffer)清空缓冲区，用绘画函数向缓冲区添加内容。这个函数只对`_F_`（储存所有页面）的情况有效（见上面的[缓冲器大小](#BufferSize)）。它还会发送一个刷新信号（[refreshDisplay](#refreshDisplay)）给墨水屏。

* 注：有点复杂，把英文抄下来：

  >Actually this procedure will send the current page to the display. This means, the content of the [internal pixel buffer](https://github.com/olikraus/u8g2/wiki/u8g2reference#getbufferptr) will be placed in the tile row given by the [current page position](https://github.com/olikraus/u8g2/wiki/u8g2reference#getBufferCurrTileRow). This means, that this procedure could be used for partial updates on paged devices (constructor with buffer option "1" or "2"). However, this will only work for LCDs. It will **not** work with most e-Paper/e-Ink devices because of the buffer switch in the display controller. Conclusion: Use this command only together with full buffer constructors. It will then work with all LCDs and e-Paper/e-Ink devices.

* 相关：[clearBuffer](#clearBuffer), [updateDisplay](#updateDisplay)




## disableUTF8Print                 {#disableUTF8Print}

* 函数原型：

  ```c++
  void U8G2::disableUTF8Print(void)
  ```

* 描述：禁止`print`函数用UTF8。这是默认设置。

* 相关：[print](#print) enableUTF8Print[#enableUTF8Print]



## enableUTF8Print                  {#enableUTF8Print}

* 函数原型：

  ```c++
  void U8G2::enableUTF8Print(void)
  ```

* 描述：允许`print`函数用UTF8。当其有效时，可以传递unicode符号的字符串给`print`函数。通常这个函数在`begin`后被调用：

  ```c++
  void setup(void) {
    u8g2.begin();
    u8g2.enableUTF8Print();		// enable UTF8 support for the Arduino print()
  }
  ```

* 相关：[print](#print), [disableUTF8Print](#disableUTF8Print)

* 示例：

  ```c++
  void setup(void) {
    u8g2.begin();
    u8g2.enableUTF8Print();		// enable UTF8 support for the Arduino print() function
  }
  void loop(void) {
    u8g2.setFont(u8g2_font_unifont_t_chinese2);  // use chinese2 for all the glyphs of "你好世界"
    u8g2.firstPage();
    do {
      u8g2.setCursor(0, 40);
      u8g2.print("你好世界");		// Chinese "Hello World" 
    } while ( u8g2.nextPage() );
    delay(1000);
  }
  ```

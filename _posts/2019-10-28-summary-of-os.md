---
layout: post
title:  操作系统总结
date:   2019-10-28 23:00:00 +0800
categories: document
tag: [Computer]
music-id: 481853665
---

> 现代操作系统总结

<!-- more -->



# 书写规范

1. 定义与定理的格式如下：

   【定义】**操作系统**：……

   【定理】**操作系统定理**：……

   若需要在下面写注释，则用引用的形式：

   > 注：……

2. 列表一律用有序表，而不是无序表，并且每一项若有标题，则标题粗体

3. 凡是有一定”步骤“的算法，均使用类 c 写：

   【方法】：
   
   ```c
   if(){
    
   } //如果
   while(){
       
   }//循环
   ```

# 第一章 引论

一些概念：

计算机的两种运行模式：
1. 内核态、管态 —— 操作系统 —— 对所有硬件具有完全访问权
2. 用户态 —— 软件 —— 只能使用机器指令中的一个子集



操作系统的功能/作用/目的：
1. 从用户的观点：作为用户与计算机之间的硬件接口
2. 从系统管理员的观点：作为资源管理者，实现资源在时间和空间上的共用
3. 从发展的观点：作为扩展机器，给计算机的功能扩展提供支持平台

## 操作系统的历史

1. 1945~1955：真空管和穿孔卡片

2. 1955~1965：晶体管和**批处理系统**
   
   1. 新技术：
      1. I/O 与计算并行：中断技术
      2. 多道程序设计：存储保护技术
   2. 特点：
      1. 用户脱机使用计算机
      2. 成批处理作业
      3. 多道程序运行
   
3. 1965~1980：集成电路和多道程序设计
   **分时操作系统**
   
   1. 新技术：时间片轮转技术（抢占式、剥夺式）
   2. 特点：
      1. 交互性
      2. 多用户
      3. 独立性
   
4. 1980~至今：个人计算机

   **实时操作系统**（嵌入式计算）

   1. 新技术：？
   2. 特点：
      1. 即时响应
      2. 高可靠性

   

   下面说几个重要的操作系统：

   1. MULTICS：分时操作系统，幻想用一台机器满足整个波士顿地区用户的需求，虽然失败，但对后续的操作系统影响深远
   2. UNIX：由参与 MULTICS 研制的贝尔实验室科学家 Ken Thompson 开发，它有两个重要的分支：
      1. BSD（Berkelet Software Distribution）：由加州大学伯克利分校开发，它有一个重要的分支：MACH，是第一个微内核的 OS，也是第一个用软件工程开发的 OS。MACH 又有一个重要的分支：苹果的 NeXT，也就是 Mac OS 的前身
      2. Linux：由芬兰学生 Linux Torvalds 开发，目前使用最广的系统
   3. Windows：微软的操作系统，最古老的是 MS-DOS，但我们现在使用的 Windows10 起源于 Windows NT，而不是 MS-DOS，因为它俩的内核完全不同

   

   ![]( http://www.ha97.com/wp-content/uploads/2010/08/Unix_history.png  "Unix 家谱")

# 第二章 进程和线程

一个非常重要的概念：

1. **并行**： 指两个或两个以上进程在**同一时刻**运行

   ![](http://img1.51cto.com/attachment/201201/162405177.jpg)

2. **并发**：指两个或两个以上进程共享一个 CPU，在**同一时间段**运行

   ![](http://img1.51cto.com/attachment/201201/162405567.jpg)



## 进程的基本概念

### 进程的状态

三状态：

1. 运行态：实际占用 CPU
2. 就绪态：可运行，但不在 CPU 上
3. 阻塞态：因等待某个事件（比如用户输入）而睡眠

如果算上初始和终止，则为五状态：

![](https://img-blog.csdn.net/20160606074023862)

在实际中，为七状态，多了两种状态：

4. 挂起阻塞状态
5. 挂起就绪状态

挂起指的是：在资源不足的情况下，操作系统对在内存中的程序进行合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存，重新进入等待被执行的状态即就绪态。

![](https://images2015.cnblogs.com/blog/901563/201610/901563-20161005233303973-1591989545.png)



在此引入三级调度的概念：

1. 高级调度（作业调度）：程序从硬盘上变为进程（创建到就绪）
2. 中级调度（内存调度）：进程从内存上转移到硬盘swap space上（挂起/释放）
3. 低级调度（进程调度）：内存内的进程轮流上下 CPU（就绪/执行）



### 进程的描述

进程的静态描述由 3 部分组成：

1. 进程控制块（PCB，process control block）：包含进程的描述信息、控制信息、资源信息
2. 程序段
3. 数据集




# 第三章 死锁

## 资源

资源分为：

1. 共享资源：资源可同时使用
2. 互斥资源：资源只允许一个进程使用
  1. 可抢占式资源：可以从拥有它的进程中抢占而不会产生副作用
  2. 不可抢占式资源：在不引起进程失败的情况下，无法从拥有它的进程中抢占过来



## 死锁的简介

死锁产生的必要条件：
1. 互斥条件：资源要么分配给一个进程，要么可用
2. 占有和等待条件：已占有资源的进程可以再请求新的资源
3. 不可抢占条件：已占有的资源不能被抢占
4. 环路等待条件：有两个或以上进程组成一个环路，每个进程都在等待下一个进程所占有的资源

处理死锁的方法：
1. 忽略它（干脆不处理了）
2. 检测死锁并恢复（监测发送并处理）
3. 仔细分配资源（避免产生）
4. 破坏死锁产生的四个条件（从源头预防）

下面将说说四种情况



## 忽略它（鸵鸟算法）

虽然听起来很扯淡，但 Linux 和 Windows 都采用这种方法

原因：
1. 死锁发生的概率很小
2. 处理死锁的开销太大

优点：
1. 方便
2. 正确

## 检测并恢复

### 检测        {#check}

假设每种资源只有一个：（基于图的检测算法）

1. 构造一个资源分配图
2. 对资源分配图进行深度优先搜索
3. 若形成了环，则形成了死锁
4. 将所有路径都遍历一次



假设每种资源有多个：（基于矩阵的检测算法）

1. 构造下面四种数据结构：

   1. 假设有 m 种资源，则**现有资源向量（existing resource vector）**为：$\vec{E}=(E_1， E_2, \cdots , E_m)$，代表每种资源总的数量

   2. **可用资源向量（available resource vector)**为：$\vec{A}=(A_1, A_2, \cdots, A_m)$，代表每种资源可用（未分配）的数量

   3. **当前分配矩阵（current allocation matrix)**：
      $$
      \begin{bmatrix}
      C_{11} & C_{12} & \cdots & C_{1m} \\
      C_{21} & C_{22} & \cdots & C_{2m} \\
      \vdots & \vdots & & \vdots \\
      C_{n1} & C_{n2} & \cdots & C_{nm}
      \end{bmatrix}
      $$
      第 $n$ 行代表进程 $n$ 已分配的资源

   4. **请求矩阵（request matrix）**：
      $$
      \begin{bmatrix}
      R_{11} & R_{12} & \cdots & R_{1m} \\
      R_{21} & R_{22} & \cdots & R_{2m} \\
      \vdots & \vdots & & \vdots \\
      R_{n1} & R_{n2} & \cdots & R_{nm}
      \end{bmatrix}
      $$
      第 $n$ 行代表进程 $n$ 请求的资源

1. 对进程 $i$ 运行如下算法：

   1. 考察 R矩阵的第 $i$ 行，若其所有列都小于 A向量，则说明它的请求可以被满足，将这行标记
   2. 若它的请求可以被满足，则它的资源会在使用完后释放出来，故将 C矩阵的第 $i$ 行加到 A向量上

1. 对其他未标记的行重复以上算法，直到没有进程可被标记为止，没有被标记的进程即为死锁进程






### 恢复

1. 利用抢占恢复：将资源从一个进程中强行取走给另一个资源使用，然后再送回。
2. 利用回滚恢复：周期性对进程进行**检查点检查（checkpointed）**，储存一系列的检查点文件，一旦检测到死锁，将进程回滚到获取资源前，然后将资源分配给一个死锁进程，而其他进程要等到死锁进程结束后才能获取资源。
3. 通过杀死进程恢复：杀死环内的进程，打破死锁；或杀死环外的进程，为环内进程提供资源。最好杀死可以从头开始运行而且不会发生副作用的进程



## 死锁避免 255

找到一种分配顺序，使得死锁不会发生，有如下两类算法：

### 资源轨迹图

![](https://raw.githubusercontent.com/mbinary/mbinary.github.io/hexo/source/images/%E8%B5%84%E6%BA%90%E8%BD%A8%E8%BF%B9%E5%9B%BE.png)

1. 横轴代表程序A，纵轴代表程序B
2. “$\leftarrow\!\rightarrow$ ” 代表程序需要资源的阶段
3. 浅阴影代表两个程序同时需要打印机或绘图仪
4. 深阴影代表两个程序出现死锁
5. 虚线代表程序运行时分配资源的轨迹，只能从下到上，从左到右
6. 目标就是使轨迹不要进入深阴影



### 银行家算法

【定义】**安全状态**：对于某个时刻的资源状态，存在一种调度次序能使每一个进程运行完毕，则称该状态为安全状态，反之为不安全状态

> 注：不安全状态并不代表一定会发生死锁，因为可能在运行过程中，有其他程序释放资源



**银行家算法（banker's algorithm）**：

1. os 分配资源 = 银行家给客户贷款
2. 在某个时刻，如果银行家无法满足任何一个客户的需求，则为不安全状态；能满足客户其中之一的要求，则为安全状态

 

运用银行家算法检测状态是否安全的步骤同上面 [检测并恢复：基于矩阵的检测算法](#check) 一模一样





## 死锁预防

破坏死锁产生的四个条件：

1. 破坏互斥条件：令资源可以被多个程序独占，采用 假脱机打印机（spooling printer），由打印机守护进程占有打印机，而其他进程向其传递打印信息。（有可能因为磁盘空间耗尽导致死锁）
2. 破坏占有并等待条件：
   1. 方法一（破坏等待）：规定所有进程在开始执行前请求所需的全部资源，这样它就不会等待（要求进程在开始时明确所需的全部资源，否则无法实现）。
   2. 方法二（破坏占有）：当进程请求资源时，要先释放所有占有的资源，再尝试一次获取所需的全部资源
3. 破坏不可抢占条件：允许抢占，但可能会出现混乱（比如打印机只打印一半）
4. 破环环路等待条件：
   1. 对资源编号，进程必须先请求编号小的资源（考虑只有两个进程，两种资源的死锁即可理解）；
   2. 另一种变种是进程不允许请求编号比当前所占有资源编号小的资源（道理同上）



## 活锁（不考）

两个进程出现了死锁，于是它们都释放了自己的资源，然后又同步的获取资源，于是又出现了死锁。最终它俩步调一致地同时给对方让路，导致谁也无法前进。

活锁与死锁的区别是：进程发生死锁后，会进入阻塞状态；但发生活锁，不会发生阻塞，只会空耗 CPU 直到时间片用完。



## 饥饿

进程有不同的优先级，优先级高的能先分配到资源，会导致优先级低的一直分配不到资源（一直被插队）





# 第四章 内存管理

## 虚拟内存 109

【定义】**虚拟内存**的基本思想：每个程序拥有自己的地址空间，这个空间被分为多个块，每个块称为**页面（page）**，页内的地址连续。页被映射到物理内存，但不一定所有的页都在内存中才能运行程序，当一个页不在内存中时，由操作系统将缺失的部分从硬盘装入内存中。

程序 ----> **虚拟地址（virtual address）** ----> **内存管理单元（Memory Management Unit，MMU）** ----> 物理内存地址


---
layout: post
title:  操作系统总结
date:   2019-10-28 23:00:00 +0800
categories: document
tag: [Computer]
music-id: 481853665
---

> 现代操作系统总结

<!-- more -->



# 书写规范

1. 定义与定理的格式如下：

   【定义】**操作系统**：……

   【定理】**操作系统定理**：……

   若需要在下面写注释，则用引用的形式：

   > 注：……

2. 列表一律用有序表，而不是无序表，并且每一项若有标题，则标题粗体

3. 凡是有一定”步骤“的算法，均使用类 c 写：

   【方法】：
   
   ```c
   if(){
    
   } //如果
   while(){
       
   }//循环
   ```



# 第三章 死锁

## 资源

资源分为：

1. 共享资源：资源可同时使用
2. 互斥资源：资源只允许一个进程使用
  1. 可抢占式资源：可以从拥有它的进程中抢占而不会产生副作用
  2. 不可抢占式资源：在不引起进程失败的情况下，无法从拥有它的进程中抢占过来



## 死锁的简介

死锁产生的必要条件：
1. 互斥条件：资源要么分配给一个进程，要么可用
2. 占有和等待条件：已占有资源的进程可以再请求新的资源
3. 不可抢占条件：已占有的资源不能被抢占
4. 环路等待条件：有两个或以上进程组成一个环路，每个进程都在等待下一个进程所占有的资源

处理死锁的方法：
1. 忽略它（干脆不处理了）
2. 检测死锁并恢复（监测发送并处理）
3. 仔细分配资源（避免产生）
4. 破坏死锁产生的四个条件（从源头预防）

下面将说说四种情况



## 忽略它（鸵鸟算法）

虽然听起来很扯淡，但 Linux 和 Windows 都采用这种方法

原因：
1. 死锁发生的概率很小
2. 处理死锁的开销太大

优点：
1. 方便
2. 正确

## 检测并恢复

### 检测        {#check}

假设每种资源只有一个：（基于图的检测算法）

1. 构造一个资源分配图
2. 对资源分配图进行深度优先搜索
3. 若形成了环，则形成了死锁
4. 将所有路径都遍历一次



假设每种资源有多个：（基于矩阵的检测算法）

1. 构造下面四种数据结构：

   1. 假设有 m 种资源，则**现有资源向量（existing resource vector）**为：$\vec{E}=(E_1， E_2, \cdots , E_m)$，代表每种资源总的数量

   2. **可用资源向量（available resource vector)**为：$\vec{A}=(A_1, A_2, \cdots, A_m)$，代表每种资源可用（未分配）的数量

   3. **当前分配矩阵（current allocation matrix)**：
      $$
      \begin{bmatrix}
      C_{11} & C_{12} & \cdots & C_{1m} \\
      C_{21} & C_{22} & \cdots & C_{2m} \\
      \vdots & \vdots & & \vdots \\
      C_{n1} & C_{n2} & \cdots & C_{nm}
      \end{bmatrix}
      $$
      第 $n$ 行代表进程 $n$ 已分配的资源

   4. **请求矩阵（request matrix）**：
      $$
      \begin{bmatrix}
      R_{11} & R_{12} & \cdots & R_{1m} \\
      R_{21} & R_{22} & \cdots & R_{2m} \\
      \vdots & \vdots & & \vdots \\
      R_{n1} & R_{n2} & \cdots & R_{nm}
      \end{bmatrix}
      $$
      第 $n$ 行代表进程 $n$ 请求的资源

1. 对进程 $i$ 运行如下算法：

   1. 考察 R矩阵的第 $i$ 行，若其所有列都小于 A向量，则说明它的请求可以被满足，将这行标记
   2. 若它的请求可以被满足，则它的资源会在使用完后释放出来，故将 C矩阵的第 $i$ 行加到 A向量上

1. 对其他未标记的行重复以上算法，直到没有进程可被标记为止，没有被标记的进程即为死锁进程






### 恢复

1. 利用抢占恢复：将资源从一个进程中强行取走给另一个资源使用，然后再送回。
2. 利用回滚恢复：周期性对进程进行**检查点检查（checkpointed）**，储存一系列的检查点文件，一旦检测到死锁，将进程回滚到获取资源前，然后将资源分配给一个死锁进程，而其他进程要等到死锁进程结束后才能获取资源。
3. 通过杀死进程恢复：杀死环内的进程，打破死锁；或杀死环外的进程，为环内进程提供资源。最好杀死可以从头开始运行而且不会发生副作用的进程



## 死锁避免 255

找到一种分配顺序，使得死锁不会发生，有如下两类算法：

### 资源轨迹图

![](https://raw.githubusercontent.com/mbinary/mbinary.github.io/hexo/source/images/%E8%B5%84%E6%BA%90%E8%BD%A8%E8%BF%B9%E5%9B%BE.png)

1. 横轴代表程序A，纵轴代表程序B
2. “$\leftarrow\!\rightarrow$ ” 代表程序需要资源的阶段
3. 浅阴影代表两个程序同时需要打印机或绘图仪
4. 深阴影代表两个程序出现死锁
5. 虚线代表程序运行时分配资源的轨迹，只能从下到上，从左到右
6. 目标就是使轨迹不要进入深阴影



### 银行家算法

【定义】**安全状态**：对于某个时刻的资源状态，存在一种调度次序能使每一个进程运行完毕，则称该状态为安全状态，反之为不安全状态

> 注：不安全状态并不代表一定会发生死锁，因为可能在运行过程中，有其他程序释放资源



**银行家算法（banker's algorithm）**：

1. os 分配资源 = 银行家给客户贷款
2. 在某个时刻，如果银行家无法满足任何一个客户的需求，则为不安全状态；能满足客户其中之一的要求，则为安全状态

 

运用银行家算法检测状态是否安全的步骤同上面 [检测并恢复：基于矩阵的检测算法](#check) 一模一样





## 死锁预防

破坏死锁产生的四个条件：

1. 破坏互斥条件：令资源可以被多个程序独占，采用 假脱机打印机（spooling printer），由打印机守护进程占有打印机，而其他进程向其传递打印信息。（有可能因为磁盘空间耗尽导致死锁）
2. 破坏占有并等待条件：
   1. 方法一（破坏等待）：规定所有进程在开始执行前请求所需的全部资源，这样它就不会等待（要求进程在开始时明确所需的全部资源，否则无法实现）。
   2. 方法二（破坏占有）：当进程请求资源时，要先释放所有占有的资源，再尝试一次获取所需的全部资源
3. 破坏不可抢占条件：允许抢占，但可能会出现混乱（比如打印机只打印一半）
4. 破环环路等待条件：
   1. 对资源编号，进程必须先请求编号小的资源（考虑只有两个进程，两种资源的死锁即可理解）；
   2. 另一种变种是进程不允许请求编号比当前所占有资源编号小的资源（道理同上）



## 活锁（不考）

两个进程出现了死锁，于是它们都释放了自己的资源，然后又同步的获取资源，于是又出现了死锁。最终它俩步调一致地同时给对方让路，导致谁也无法前进。

活锁与死锁的区别是：进程发生死锁后，会进入阻塞状态；但发生活锁，不会发生阻塞，只会空耗 CPU 直到时间片用完。



## 饥饿

进程有不同的优先级，优先级高的能先分配到资源，会导致优先级低的一直分配不到资源（一直被插队）





# 第四章 内存管理

## 虚拟内存 109

【定义】**虚拟内存**的基本思想：每个程序拥有自己的地址空间，这个空间被分为多个块，每个块称为**页面（page）**，页内的地址连续。页被映射到物理内存，但不一定所有的页都在内存中才能运行程序，当一个页不在内存中时，由操作系统将缺失的部分从硬盘装入内存中。

程序 ----> **虚拟地址（virtual address）** ----> **内存管理单元（Memory Management Unit，MMU）** ----> 物理内存地址


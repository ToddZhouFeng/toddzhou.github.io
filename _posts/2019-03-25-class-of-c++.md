---
layout: post
title:  c++中类的相关知识整理
date:   2016-08-27 01:08:00 +0800
categories: document
tag: c++
music-id: 465675773
---

* content
{:toc}
&emsp;&emsp;由于老师上课时我没认真听（没办法...老师讲课慢死了，还不如自己看书），学完类后我十分头晕...故写一篇文档总结一下。顺便吐槽一下，书编得也太混乱了吧！

# 基础

类定义的说明语句如下：

~~~c++
class <类名>
{
    public://公有段成员，类内、类外、派生类可见
    
    protected://保护段成员，类内、派生类可见，类外不可见
    
    private://私有成员，类内可见，类外、派生类不可见
    
};//不要漏了';'
~~~

## 函数

&emsp;&emsp;在类内声明函数和在类外一样

~~~c++
<返回值> function(<形参>);//不要漏了";"
~~~

&emsp;&emsp;对于简单的函数，可以直接在类内写。对于复杂的函数，在类外需要这样写：

~~~c++
<返回值> <类名>::function(<形参>)
{
    //函数体
}
~~~

&emsp;&emsp;与python中的self类似，c++也有一个this. 具体原理如下：当一个类成员调用成员函数时，编译器会把类成员的地址传入`this`，任何对类成员的直接访问都被看作`this`的隐式引用，在函数内部，隐式地使用`this`指向成员，即`<数据成员>`相当于`this-><数据成员>`。

&emsp;&emsp;这就有个问题，`this`本质上是一个普通指针，如果你的数据成员为常量，你需要将`this`变为指向常量的指针：

~~~
<返回值> function(<形参>)const;
~~~

&emsp;&emsp;在外部也要加`const`：

~~~
<返回值> <类名>::function(<形参>) const
{
    //函数体
}
~~~



## 构造函数

~~~c++
<类名>()；//以类名为函数名
~~~

&emsp;&emsp;作用为初始化函数，**无法用`const`修饰**。如果不写的话，系统会提供一个**默认构造函数**，它会做如下事：

* 如果存在类内的初始值，用它来初始化成员
* 否则，默认初始化该成员

&emsp;&emsp;但默认构造函数不是万能的，以下情况需要自己编一个构造函数：

* 类中有内置类型或符合类型（如数组和指针）
* 类被包含在其他类中（类中的类无法使用默认函数初始化）

### default

&emsp;&emsp;如果你需要编一个构造函数，但要做的事和系统差不多，可以这样写

~~~
<类名>()=default;//在类内这样写
~~~

### 初始值列表

~~~c++
<类名>(<形参>):<数据数据成员>(<形参>)
~~~


---
layout: post
title:  c++中类的相关知识整理
date:   2019-03-25 22:00:00 +0800
categories: document
tag: c++
music-id: 465675773
---

* content
{:toc}
> &emsp;&emsp;前言：为什么要多此一举写这个呢，还不是因为书上写得太乱了......我参考的资料是C++ Primer和华南理工的教科书

# 基础知识

> 类的基本思想是数据抽象和封装。——《C++ Primer》

类由**数据成员**和**成员函数**组成。

## 成员函数

成员函数的声明在类内，定义则可以在类内或内外，在内外定义时要指明函数的作用域（因为类本身就是一个作用域）。比如这个图书的销售数据类：

```c++
struct Sales_data{
    std::string isbn() const {return bookNo;}#返回isbn码#类内声明+定义
    double avg_price() const;#返回平均售价 #类内声明，注意不要忘了";"
}

double Sales_data::avg_price() const{#类外定义，注意不要忘了"::"
    if (units_sold)
    	return revenue/units_sold;
    else
    	return 0;
}
```

### this指针

调用成员函数时，用`类名.函数名()`的形式。当我们调用成员函数时，实际上是替某个具体对象调用它，为了使成员函数知道使哪个具体对象调用它，C++规定了一个名为`this`的隐式参数，当编译时，具体对象的地址会传入`this`。比如：

```C++
Sales_data total;
total.isbn();#伪代码，相当于：Sales_data::isbn(&total)
```

如果你的类是一个常量类（即具体化类时用了const），由于this指针是一个指向非常量的常量指针，所以不能绑定到常量对象上。此时可以通过在函数后面加const，使this能指向常量。比如上上面的`isbn()`

最后说一句，this是隐式参数意味这我们不能定义this，但我们依然可以在函数内使用this，比如上面`isbn()`可以写成：

```c++
std::string isbn() const {return this->bookNo;}
```



## 构造函数

构造函数是特殊的成员函数，其任务是初始化类对象的数据成员。它有几个特点：

* 构造函数的名字与类名相同；
* 构造函数不能声明为const；

如果不对数据成员提供初始值，则通过**默认构造函数**来初始化，它无须任何实参（也就没任何形参）。如果我们没有定义构造函数，则编译器会隐式定义一个**合成的默认构造函数**，它会将默认初始化数据成员。

**但是某些类不能用合成的默认构造函数，具体有如下几种类**：

* 只要我们定义了构造函数，无论是否是默认构造函数，编译器都不会生成合成的默认构造函数；
* 数据成员含有数组和指针时，其默认初始化的值是未定义的，因此需要在类内初始化，或定义一个自己的默认构造函数；
* 如果类中包含其他类型的成员且这个成员的类型没有默认构造函数，则编译器无法初始化该成员。

### default

如果我们定义的默认构造函数和合成的默认构造函数干的事差不多，则可以直接在默认构造函数的声明的括号后写上`= default;`

### 构造函数初始值列表

```c++
Sales_data(const std::string &s): bookNo(s) {}
```

可以在默认函数的括号后面加`数据成员(形参)`来为数据成员赋值，其相当于：

~~~c++
Sales_data(const std::string &s) {
    bookNo=s;
}
~~~

如果要对多个数据成员初始化，它们之间用逗号隔开：

~~~c++
Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}
~~~

因为这些构造函数的唯一的作用是赋初值，所以函数体为空。